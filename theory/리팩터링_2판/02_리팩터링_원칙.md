# 리팩터링 원칙

## 2.1 리팩터링 정의

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법

> 리팩터링(하다): [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

 <br />
 위 정의에 따르면, 코드를 정리하는 작업이 모두 리팩터링에 속하는 것이 아니고, 특정한 방식에 따라 코드를 정리하는 것만이 리팩토링에 속한다.

 <br />

> ex) 앞으로 몇 시간은 리팩터링(1)할 것 같은데 그 사이 적용하는 리팩터링(2)은 수십 가지나 될 것 같다.
>
> 1.  동사
> 2.  명사

 <br />
 
 리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다. 그 동안에는 코드가 항상 정상 작동하므로, 전체 작업이 끝나지 않아도 중단할 수 있다. 즉 리팩터링하기 전 후의 코드가 동일히 동작해야 한다.

 <br />
 <br />
 <br />

## 2.2 두 개의 모자

켄트 벡은 기능 추가와 리팩터링을 두 개의 모자에 비유했다.

기능을 추가할 때는 '기능 추가' 모자를 쓰고, 새 기능을 추가하기만 한다. 이 때 기존 코드는 건드리면 안된다. 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.

리팩터링을 할 때는, '리팩터링' 모자를 쓰고 기능 추가는 하지 않고 코드 재구성에 집중한다. 새로운 TC를 발견하거나 인터페이스를 변경해야하는 등의 특수 상황 외에는 테스트도 변경하지 않는다.

 <br />
 <br />
 <br />

## 2.3 리팩터링하는 이유

**1. 리팩터링하면 소프트웨어 설계가 좋아진다.**

리팩터링은 소프트웨어의 내부 설계(아키텍처)를 파악하기 쉽게 하고, 이로써 코드의 구조를 지탱해준다. 이후에 수정을 하거나 기능 추가를 할 때, 드는 노력을 줄일 수 있다.

**2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.**

작성한 사람 조차도 코드를 이해하는 데에도 시간이 필요하다. 이 코드의 목적이 잘 드러나게, 다시 말해 작성자의 의도를 더 명확하게 전달하도록 리팩터링을 통해 개선할 수 있다.

**3. 리팩터링하면 버그를 쉽게 찾을 수 있다.**

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다. 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되면서, 새로운 인사이트를 얻을 수 있다. 또한 코드를 리팩터링하다보면 코드의 해상도가 올라가게 된다. 버그가 명확해지고, 가정하던 부분들이 분명히 드러난다.

> 난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요 - 켄트 벡

**4. 리팩터링하면 프로그래밍 속도를 높일 수 있다.**
<img width="300" alt="스크린샷 2025-02-06 오후 10 01 29" src="https://github.com/user-attachments/assets/2ba370d6-1911-4b4e-9b05-ef9ec1a4e01b" />

초기에는 기능을 곧바로 추가하는 것이 빠르지만, 규모가 커지면 추가할 수록 기존 코드베이스에 새 코드를 추가하는 데에 시간이 걸린다. 또한 기능을 추가하고 나면 버그가 발생하고, 이를 해결하는 데에는 더 많은 시간이 필요하다. 이런 부담이 겹쳐지면서 코드 개발에 시간이 더 필요해진다. 즉 시간이 x축, 기능의 누적이 y축인 2차원 좌표평면에서 나쁜 설계는 초반에 기울기가 가파르다가 점점 완만해지는 곡선의 양상을 나타낸다.

<img width="300" alt="스크린샷 2025-02-06 오후 10 01 41" src="https://github.com/user-attachments/assets/4d01e81f-9e95-4b2c-8776-6e3ab6a6972e" />

좋은 설계의 경우, 처음에는 시간 대비 기능의 누적 속도가 나쁜 설계보다 느리나, 이후 월등히 높은 상승세를 보인다. 이 원인은 소프트웨어 내부 품질에 있다. 내부 설계가 잘 되어있으면, 새로 기능을 추가할 지점과 고쳐야할 지점을 쉽게 찾을 수 있다. 이렇게 내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.

 <br />
 <br />
 <br />

## 2.4 언제 리팩터링해야 할까?

> 3의 법칙(삼진 리팩터링) - 돈 로버츠
>
> 1. 처음에는 그냥 한다.
> 2. 비슷한 일을 두 번째로 하게 되면, 일단 계속 진행한다.
> 3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

 <br />

### 계획된 리팩터링

**준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기**

코드베이스에 기능을 새로 추가하거나, 버그를 잡을 때 리팩터링하기 좋다. 이 시점에 현재 코드를 살펴보면서, 구조를 바꿈으로써 작업이 편해질 구간을 찾는다. 중복 코드를 *함수 매개변수화하기*를 통해 줄일 수도 있다. 이렇게 준비를 위한 리팩터링(Preparatory Refactiong) 통해 기반을 지속할 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다.

**이해를 위한 리팩터랑과 쓰레기 줍기 리팩터링**

코드를 수정하려면 먼저 그 코드가 하는 일과 의도를 명확히 파악해야 한다. 리팩토링을 하면 워드 커닝햄의 말처럼 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그렇게 수정한 코드를 테스트해보면 생각이 맞았는 지 채점해볼 수 있다.

또한 정리하는 과정에서 효과를 볼 수도 있다. 코드가 깔끔하게 정리되면 전에 보이지 않던 설계를 파악할 수 있다. 이렇게 리팩터링을 통해, 코드의 깊은 수준까지 이해하게 된다. 이것을 이해를 위한 리팩터링(Comprehension Refactoring)이라고 한다.

파악하던 도중 비효율적인 부분을 파악할 수도 있다. 간단히 수정할 수 있는 것은 즉시, 시간이 필요할 경우 나중에 처리하는 것을 쓰레기 줍기 리팩터링(Litter-Pickup Refactoring)이라고 한다.

### 수시로 하는 리팩터링

뛰어난 개발자는, 새 기증을 추가하기 쉽도록 코드를 '수정'하는 것이 그 기능을 가잘 빠르게 추가하는 길임을 알고 있다. 리팩터링과 프로그래밍을 구분 짓지 말라. 버그를 잡을 때, 기능을 추가할 때에 자연스럽게 리팩터링 과정을 녹인다. 이것은 당면한 문제뿐만 아니라, 앞으로 할 작업에도 도움을 준다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고(단, 만만치 않을 수 있다) 그런 다음 쉽게 수정하자. - 켄트 벡

계획된 리팩터링을 폄하하는 것이 아니다. 그동안 소홀했다면 집중적으로 리팩터링을 해야할 필요가 있다. 그러나 이 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야 한다.

버전 관리 시스템에서도 리팩터링과 커밋을 분리하는 경우도 분명 있다. 그러나 리팩터링은 기능 추가와 밀접하게 엮인 경우가 많아 굳이 나누는 것은 시간 낭비일 수 있다. 또한 리팩터링의 기준이 되는, 맥락 정보가 사라져서 수정한 이유를 알 수 없어진다. 이를 명심하고 팀에 적합한 방식을 적용해야한다.

**오래 걸리는 리팩터링**

리팩터링이 코드를 깨트리지 않는다. 일부를 변경해도 모든 기능이 항상 올바르게 동작한다. 그러니 팀 전체가 일정 기간동안 리팩터링에 매달리는 것보다 주어진 문제를 조금씩 해결해가는 편이 더 효과적일 수 있다.

### 업무와 리팩터링의 접목

**코드 리뷰에 리팩터링 활용하기**

코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다. 대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움된다. 깔끔한 코들를 작성하는 데에도 굉장히 중요하다. 다른 사람의 인사이트를 얻을 수 있다.

리팩터링은 다른 사람의 코드를 리뷰하는 데에도 도움이 된다. 코드를 보고 새로운 아이디어가 떠올랐을 때, 먼저 리팩터링을 한다면 쉽게 구현할 수 있는 지 살펴본다. 그렇다면 리팩터링 과정에 들어간다. 이렇게 반복하다보면 아이디어를 실제로 적용했을 때의 모습을 더 명확히 볼 수 있다. 또한 리팩터링으로 결과를 즉시 구현해볼 수 있기에, 리뷰를 구체적으로 도출하는 데에도 도움이 된다.

리뷰 성격에 따라 둘을 접목하는 방법은 달라진다. 코드 작성자가 맥락을 설명하고, 리뷰어의 변경 의도를 제대로 이해할 수 있어 참석자가 참석하는 방식이 좋다. 필자가 추천하는 방법은 짝 프로그래밍(pair programming)과 같이 작성자와 리뷰어가 나란히 앉아서 리팩터링 하는 것이다.

**관리자에게는 뭐라고 말해야 할까?**

관리자가 기술에 정통하고, 설계 지구력 가설도 잘 이해하고 있다면 리팩터링의 필요성을 쉽게 설등할 수 있다. 그러나 반대의 경우, 관리자에게 리팩터링한다고 말하지 않는 것을 추천한다. 관리자는 일정이 최우선이다. 그리고 그에 대한 구체적인 방법은 프로인 개발자가 판단해야한다. 이 '방법'에는 리팩터링을 뜻한다.

**리팩터링하지 말아야 할 때**

내부 동작을 이해해야할 시점에 리팩터링은 효과를 본다. 즉, 수정할 필요가 없는 경우도 분명히 존재한다. 예를 들면 외부 API 다루듯 호출해서 쓰는 코드 등 말이다.

리팩터링과 새로 작성하는 것을 비교했을 때, 후자가 더 쉬울 때도 있다. 직접 리팩터링하지 않은 경우 어느 쪽이 더 쉬운지 확실히 알 수 없을 때도 많다. 이를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침 되어야 한다.

 <br />
 <br />
 <br />

## 2.5 리팩터링 시 고려할 문제

**새 기능 개발 속도 저하**

준비를 위한 리팩터링을 통해 변경이 더 쉬워진다는 확신이 있다. 그러나 직접 건드릴 일이 거의 없거나, 불편한 정도가 심하지 않으면 리팩터링 과정은 건너진다. 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 많은 가치를 창출하는 것이다. 상황에 맞게 리팩터링을 조율하는 것이 중요하다.

그러나 많은 개발자들이 관리자를 핑계로, 또는 리팩터링에 대한 오해로 이를 미루고 있다. 리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다. 다른 이들과 대화할 때도 이 점을 명심해야한다. 리팩터링은 클린코드나 바람직한 엔지니어링 습관으로만 치부하지 않고, 코드베이스를 건강히 가꾸는 과정이며, 이것은 생산성 차이로 직결된다는 것을 이해해야하고 팀원을 설득할 수 있어야 한다.

**코드 소유권**

코드 소유권이 나뉘어 있으면 리팩터링에 방해가 된다. 그러나 리팩터링을 할 수 없는 건 아니다. 기존 코드를 대체할 새 코드를 작성하고, 이를 사용하는 방식이 있다. 그러나 이는 인터페이스의 복잡도를 야기한다. 이런 상황을 방지하기 위해, 팀원 누구나 코드에 수정 권한이 있어야 한다.

여러 팀으로 구성된 조직에도 이 방식을 적용할 수 있다. 예를 들어 어떤 팀은, 타 팀이 자기 팀 코드의 브랜치를 따서 수정하고 커밋을 요청하는 방식을 취한다. 변경 사항 커밋을 클라이언트를 관리하는 쪽에서 허용할 수 있도록 하는 것이다. 이 방식은 대규모 시스템 개발 시 잘 어울린다.

**브랜치**

독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어렵다. 리베이스나 병합(merge)의 차안이 있지만, 여러 기능 브랜치에서 동시에 개발이 진행된다면 이를 해결할 수 없다.

특히 병합이 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 기하급수적으로 늘어난다. 그렇기에 통합 주기를 짧게 관리하는, 지속적 통합(Continuous Integration, CI), 또는 트렁크 기반 개발(Trunk-Based Development, TBD)를 통해 문제를 해결할 수 있다.

또한 CI는 리팩터링 과정에서 생기는 충돌 문제를 줄일 수 있어 리팩터링과의 궁합 또한 좋다. 이는 둘을 합친 익스트림프로그래밍(Extreame Programming, XP)가 등장한 이유이기도 하다. 그러나 CI를 적용하기 위해서는, 마스터를 건강히 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 기능 토글(feature toggle)을 적용하여 완료되지 않은 기능이 시스템 전체를 망치지 않도록 해야한다.

**테스팅**

리팩터링을 검증하고, 오류를 재빨리 잡기 위해서는 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 수시로, 빠르게 실행되어야 한다. 달리 말하면 리팩터링하기 위해서는 (대부분의 경우에) 자가 테스트 코드(self-testing code)를 마련해야 한다.

자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다. 테스트가 실패한다면 가장 최근 버전에서 어떤 부분이 달라졌는 지 살펴볼 수 있기 때문이다. 변경 단위가 적은 리팩터링의 특성 상, 그리고 테스트 주기가 짧은 경우에 더더욱 버그를 쉽게 찾을 수 있다. 이는 리팩터링 과정 시 버그의 불안감을 해소할 수 있다.

자동 리팩터링 기능이 제공된다면 테스트 코드는 불필요하다. 안전한 리팩터링만 활용한다면 테스트 없이 리팩터링할 수 있다. 활용할 수 있는 리팩터링 기법이 제한되나, 자동 리팩터링들만으로도 효과는 충분하다. 이렇게 검증된 몇 가지 리팩터링 기법만 조합해서 사용하자는 흐름이 등장하게 되었다. 물론 각 단계를 신중하게 진행해야 하고, 구체적인 방법도 언어마다 달라진다.

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서, 자연스럽게 CI와도 밀접히 연관된다. CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(Continuous Delivery, CD)의 핵심이기도 하다.

**레거시 코드**

레거시 시스템을 파악할 때 리팩토링은 도움이 된다. 그러나 테스트 코드 없이는 명료하게 끝낼 수 없다. 그러므로 테스트를 보강해야한다. 보통 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트할 수 있으나, 그렇지 못한 경우도 쉽게 마주칠 수 있다. 그렇기에 테스트를 추가할 틈새를 찾아서 테스트 할 수 있어야 한다. 이 틈새는 역시 리팩터링이 만들어 준다. 위험하지만 감내해야할 방법이다. 안전한 자동 리팩터링 도구가 큰 도움이 되지만, 그래도 상당히 어려운 작업이다.

이제 레거시 시스템을 리팩터링해보자. 단번에 하는 것 보다, 조금씩 나눠서 공략하는 것이 좋다. 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 코드를 훑게 되는 횟수와 그 부분을 개선했을 때 얻는 효과는 비례하기 때문이다.

**데이터베이스**

진화형 데이터베이스 설계(evolutionary database design)와 데이터베이스 리팩터링 기법은 널리 적용되고 있다. 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데에 있다.

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리즈하는 것이 대체로 좋다는 점에서 다른 리퍁거링과 다르다. 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽게 하기 위함이다. 이렇게 데이터베이스를 변경하는 방식은 병렬 수정(paralle change, 또는 팽창-수축)의 일반적인 예다

 <br />
 <br />
 <br />

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

코딩 전 아키텍처를 확정지으려면 반드시 소프트웨어 요구사항을 사전에 모두 파악해야 한다. 그러나, 실제로 소프트웨어를 사용해보고 업무에 미치는 영향을 직접 확인하고 나서야 정말로 원하는 바를 알게된다. 즉 소프트웨어 요구사항을 사전에 미리 파악한 후 아키텍처를 확정짓는 것은 실현하기 어렵다.

이에 대응하기 위해, 향후 변경에 유연하게 대처할 수 있는 유연성 메커니즘(flexibility mechanism)을 소프트웨어에 심어두는 것이다. 물론 메커니즘들이 대개 그렇듯 치러야 할 비용이 있다. 예를 들면 함수를 정의하는 과정에서 범용성을 고려하여 작성하면, 후일 변경에 유연하게 대처할 수 있다. 그러나 당장의 쓰임에 비해 함수가 복잡해지고, 요구사항의 방향성이 다르게 바뀌는 등으로 오히려 변화에 대응하는 능력을 떨어트릴 위험성이 있다. 즉, 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 얼마든지 추가할 수 있으나, 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거치고 추가해야 한다.

리팩터링은 코드 작성 이후로도 아키텍처를 변경시킬 수 있기 때문에, 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꿔놓았다. 리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데에 있다. 즉 리팩터링을 활용한다면, 현재까지 파악한 요구사항만 집중하여 이를 해결하는 소프트웨어를 설계 및 구축한다. 진행하면서 사용자의 요구사항을 더 잘 이해하게 된다면 아키텍처도 그에 맞게 리팩터링하여 바꾼다.

예상되는 변경을 미리 반영하는 리팩터링을 미루게 될 경우, 나중에 얼마나 어려워질 지 가늠하는 것이 판단에 도움에 많이 된다. 확신이 들 때만 유연성 메커니즘을 미리 추가한다. 이런 방식을 간결한 설계(simple design), 점진적 설계(incremental design), YAGNI 등으로 부른다.

YAGNI란, 익스트림 프로그래밍 원칙 중 하나인 "당장에 필요한 기능만으로 최대한 간결하게 만들라(_"You Aren't Going To Need It"_)"는 뜻이다. 물론 YAGNI를 받아들인다고 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아니다. 리팩터링으로는 변경하기 어려워서 미리 생각해두면 시간이 절약되는 경우도 얼마든지 있다. 그러나 문제를 더 깊이 이해하게 되었을 때 처리하는 경향을 통해, 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구하는 진화형 아키텍처(Evolutionary architecture) 원칙이 발전하는 계기가 되었다.

 <br />
 <br />
 <br />

## 2.7 리팩터링과 소프트웨어 개발 프로세스

팀이 따르는 실천법에 따라 리팩터링 효과는 크게 달라진다. 이는 2.5절 "리팩터링 시 고려할 원칙"을 통해서도 알 수 있는 내용이다. 리팩터링은 최초의 애자일 소프트웨어 방법론 중 하나인 익스트림 프로그래밍(XP)이 도입되면서 퍼지기 시작했다. XP의 두드러진 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다. 현재 애자일 사고(agile thinking)이 주류로 자리잡았지만, 이를 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 반드시 뒷받침 되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.

리팩터링의 첫 번째 토대는 자가 테스트 코드다. 프로그래밍 도중 발생한 오류를 확실히 걸러내는 테스트를 자동으로 수행할 수 있어야 한다. 덧붙혀 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(Test-Driven Development, TDD)라고 한다. 두 번째 토대는 지속적 통합(CI)이다. 팀으로 개발하면서 리팩터링을 하려면, 각 팀원이 다른 사람의 작업을 방해하지 않으면서 언제든지 리팩터링할 수 있어야 한다. CI를 이용하여 결과를 빠르게 동료와 공유하고, 발생할 수 있는 문제를 미연에 방지할 수 있다.

이렇게 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세 기법은 잘 조화한다면 요구사항 변화에 재빠르게 대응하고 안정적인 선순환 구조를 이룰 수 있다. 더구나 YAGNI와 이 실천법들은 서로의 토대이다. 추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽기 때문이다. 이렇게 핵심 실천법을 갖췄다면 애자일의 이점은 충분히 취할 수 있는 토대를 마련하는 것이다. 지속적 배포를 통해 소프트웨어를 항상 릴리즈에 대비할 수 있게 하고, 위험 요소를 줄이며, 기술적 제약 보다는 비즈니스 요구에 맞춰 릴리즈 일정을 계획할 수 있다. 그러나 이들을 실무에 적용하기는 만만치 않다는 것, 어떤 접근법이든지 충분한 연습과 실력이 뒷받침 되어야함을 알아야 한다.


 <br />
 <br />
 <br />


## 2.8 리팩터링과 성능

리팩터링을 하면 소프트웨어가 느려질 수도 있다. 그러나 성능을 튜닝하기에는 더 쉬워진다. 즉 리팩터링을 통해 코드를 튜닝하기 쉽게 만들고, 이후 원하는 속도가 나게끔 다시 튜닝하면 소프트웨어를 빠르게 만들 수 있다.

 <br />

**성능을 향상시키는 세 가지 방법**

시간 예산 분배(time budgeting)는 가장 업격한 방법으로, 하드 리얼타임 시스템에서 많이 사용된다. 이 방법은 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다. 컴포넌트는 자원 예산을 초과할 수 없다. 다만 주어진 자원을 다른 컴포넌트와 서로 주고받을 수는 있다. 특히 엄격한 시간 엄수를 강조하는 것이 특징이다. 데이터가 늦게 도착하면 안 되는 시스템에서는 이런 점이 매우 중요하나, 사내 정보 시스템과 같은 프로젝트에는 맞지 않다.

당연하게도 끊임없이 관심을 기울인다면 성능을 높일 수 있다. 하지만 프로그래머들은 높은 성능을 유지하기 위해 어떤 일이든 하나, 실제 효과는 변변치 않다. 이 과정에서 프로그램이 더 어려워지기도 하고, 개발이 더뎌지기도 한다. 이 방식은 성능을 개선하기 위한 최적화가 프로그램 전반에 퍼지는데, 각각의 개선은 프로그램의 특정 동작에만 관련될 뿐, 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때도 많다.

> **아무 것도 안 만드는 데도 시간이 걸린다 _론 제프리**<br />
> 교훈은 간단하다. 시스템에 잘 알더라도 섣불리 추측하지 말고 성능을 측정 해봐야 한다. 그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.

성능은, 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 점에서 흥미롭다. 그래서 코드 전체를 고르게 최적화하는 것보다, 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 쉽게 만드는 것이 세 번째 방법이다. 성능 측정과 최적화 대상 특정, 리팩터링, 컴파일과 테스트, 이 4 단계를 목표치까지 계속해서 반복하는 것이다. 이렇게 성능을 측정하고 집중해서 최적화하면 적은 노력으로 훨씬 더 큰 효과를 볼 수 있다.


**리팩터링은 성능 개선에 도움이 된다**

성능 튜닝에 투입할 시간을 벌 수 있다는 점, 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다는 점에서 리팩터링은 결과적으로 성능 개선에 도움이 된다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수 있으나, 최적화 단계에서 코드를 튜닝하기 훨씬 쉬워지기 때문에 결국 더 빠른 소프트웨어를 얻을 수 있다.


 <br />
 <br />
 <br />


## 2.9 리팩터링의 유래

용어의 정확한 유래를 찾을 수는 없으나, 훌륭한 프로그래머는 항상 자신의 코드를 정리해왔다.

워드 커닝햄과 켄트 벡은 1980년대부터 스몰토크를 활용해 개발해왔다. 객체 지향 언어인 스몰토크는 기능이 풍부한 소프트웨어를 빠르게 작성할 수 있는 굉장히 역동적인 환경인데, 컴파일-링크-실행 주기가 상당히 짧아서 마지막 컴파일 시점만 안다면 수정 작업을 빠르게 진행할 수 있었다. 이런 환경에 특화된 개발 방법론을 고민했고, 그 결과로 XP가 탄생했다. 이 과정에서 리팩터링과 생산성의 관계성을 깨닫고 리팩터링을 실전 프로젝트에 활용하면서 개선해나갔다.

XP가 큰 반향을 일으키면서 리팩터링이란 개념이 스몰토크 개발 문화에 중요한 요소로 자리 잡았다. 스몰토크 커뮤니티를 주도하던 인물 중 하나인 랄프 존슨은 효율적이고 유연한 프레임워크를 개발하는 데에 리팩터링이 어떻게 기여하는 지 연구했다. 랄프의 학생인 빌 옵다이크는 리팩터링의 잠재 가치를 간파하고, 이를 다른 언어에 적용할 수 있다고 생각했다. 박사 연구 주제로 의미 보존(semantic-preserving) 리팩터링 기법들을 연구하고 리팩터링 후 의미 보존 여부 검증 방법과 도구로 구현하는 방법을 발표했다. 빌의 아이디어를 발전시켜 존 브랜트와 돈 로버츠는 스몰토크 환경을 위한 최초의 리팩터링 도구를 개발했다.


 <br />
 <br />
 <br />


## 2.10 리팩터링 자동화

실제 리팩터링을 대신 처리해주고, 따로 테스트를 할 필요 없을 정도로 안정화 된 자동 리팩터링을 지원하는 도구들이 등장하고 있다. 최초의 자동 리팩터링은 존 브랜트와 돈 로버츠가 개발한 스몰토크용 <리팩터링 브라우저에서> 등장했고, 이것이 2000년대 초반에 자바 커뮤니티에 급속도로 퍼졌다. 곧 C# 또한 등장했고, 나중에 <비주얼 스튜디오> 팀에서 자체적으로 리팩터링 기능을 추가했다. 현재는 에디터나 독립 도구에서도 리팩터링 기능을 제공할 정도로 자동 리팩터링이 흔해졌다. 이 리팩터링 도구들에 깔린 원칙들을 짚어보자.

리팩터링을 자동화하는 가장 어설픈 방법은 소스 코드의 텍스트를 직접 조작하는 것이다. 자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리(syntax tree)로 해석해서 다뤄야한다. 이를 조작하는 방식이 코드의 원래 의미를 보존하는 데 훨씬 유리하기 때문이다. 그런데 단순히 구문 트리를 해석해서 수정하는 것만으로는 리팩터링을 구현할 수 없다. 변경된 구문 트리를 다시 에디터 화면에 텍스트로 바꿔 표현해야 한다. 그래서 리팩터링 기능을 제대로 구현하기란 상당히 어렵다.

정적 타입 언어라면 훨씬 안전하게 구현할 수 있는 리팩터링 수가 늘어난다. 도구에서 언어의 정적 타입 능력을 활용하여 메서드가 속한 클래스를 정확히 알아낼 수 있기 때문에, 변경할 메서드만 제대로 골라낼 거라고 믿을 수 있다. 간혹 도구에서 그 이상까지 처리해주는 경우도 있다. 이처럼 IDE에서 제공하는 리팩터링 기능이 강력하기 때문에, 프로그래밍 효율 면에서 텍스트 에디터를 사용하는 것보다 훨씬 유리하다.

IDE는 구문 트리를 분석해서 리팩터링하기 때문에, 단순한 텍스트 에디터와는 비교할 수 없을 만큼 유리하다. 최근에는 구문 트리를 구성해서 텍스트 에디터에 API 형태로 제공하는 소프트웨어인 언어 서버(Language Server)가 뜨고 있따. 이는 다양한 텍스트 에디터를 지원할 수 있고, 정교한 코드 분석과 리팩터링 기능을 제공한다.

그러나 분명 허점은 존재하기에, 중간에 꼬인 부분이 없는 지 이따금 테스트로 확인하는 것이 바람직하다. 즉 리팩터링 자동화 도구를 사용하더라도 충분한 테스트는 항상 필요하다.


 <br />
 <br />
 <br />


## 2.11 더 알고 싶다면 : 리팩터링 기본 이상이 궁금할 때

- ⌜리팩터링 워크북⌟ - 윌리엄 웨이크 저, 인사이트, 2006
- ⌜패턴을 활용한 리팩터링⌟ - 조슈아 케리에프스키 저, 인사이트, 2011
- ⌜리팩터링 데이터베이스⌟ - 스캇 엠블러, 프라모드 사달게 공동 저, 위키북스, 2007
- ⌜리팩토링 HTML⌟ - 엘리엇 러스티 헤롤드 저, 에이콘출판사, 2009
- ⌜레거시 코드 활용 전략⌟ - 마이클 페더스 저, 에어콘출판사, 2018
- ⌜Refactoring:Ruby Edition⌟ - 제이 필즈, 셰인 하비 공동 저, Addition-Wesley, 2009
- [깃허브 지원 페이지](https://github.com/WegraLee/Refactoring/blob/master/README.md)
- [리팩터링 웹사이트](https://refactoring.com/)

