# 테스트 구축하기

리팩터링을 제대로 하려면 숨어있는 실수를 잡아주는 테스트 스위트가 뒷받침되어야 한다. 하지만 리팩터링을 하지 않더라도, 좋은 테스트를 작성하는 것은 개발 효율을 높혀준다.

<br />
<br />
<br />

## 4.1 자가 테스트 코드의 가치

> 모든 테스트를 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자.

테스트가 성공했는 지 확인하려면 의도한 결과와 테스트 결과가 같은지만 비교하면 된다. 테스트 자동화를 통해 테스트에 들어가는 일을 줄일 수 있다. 이렇게 한다면 컴파일할 때마다 테스트도 함께 병행되면서 디버깅 시간이 줄어들어 생산성이 급상승한다. 이렇듯 자가 테스트 코드 자체뿐 아니라 테스트를 자주 수행하는 습관도 버그를 찾는 데에 큰 영향을 끼친다. 그러나 테스트를 작성하려면 소프트웨어 제품 본체 외의 부가적인 코드를 상당량 작성해야 한다. 효과를 경험하기 전에는 설득은 쉽지 않다.

테스트를 작성하기 가장 좋은 시점은 프로그래밍을 시작하기 전이다. 저자는 기능을 추가해야할 때부터 테스트를 작성한다. 이 경우 기능에 어떤 것이 필요할 지 고민할 수 있고, 구현보다 인터페이스에 집중하게 되는 장점이 있다. 그리고 테스트를 모두 통과한 시점이 코드를 완료한 시점이기에, 완료 시점을 정확하게 판단할 수 있다. 켄트 벡은 이처럼 테스트부터 작성하는 것을 기반으로 테스트 주도 개발(Text-Driven Development, TDD)이라는 기법을 창시했다. 이는 다음의 과정을 반복한다.

1. (처음에는 통과하지 못할) 테스트를 작성
2. 1을 통과하게끔 토드를 작성
3. 결과 코드를 리팩터링

<br />
<br />
<br />

## 4.2 테스트할 샘플 코드

> 이 장의 목적은 자가 테스트 코드 작성법을 파악하는 데에 있다. 그렇기에 해당 페이지에 상세 내용이 기입될 예정이다.

UI, 영속성, 외부 서비스 연동과는 관련 없는 가장 쉬운 코드부터 보는 것이 좋은데, 이런 식으로 성격에 따라 코드를 각기 분리하는 것이 좋다. 만일 비즈니스 로직 코드가 복잡하다면, UI와 로직을 분리하고 테스트에 유용하도록 수정하는 것이 좋다.



**비즈니스 로직 코드**

1. Province 클래스
- 지역 전체를 표현
- 해당 클래스의 생성자는 JSON 문서로부터 만들어진 JS 객체를 인수로 받음

``` js
 // 생산자를 표현

 constructor(doc) {
  this._name = doc.name;
  this._producers = [];
  this._totalProduction = 0;
  this._demand = doc.demand;
  this._price = doc.price;
  doc.producers.forEach(d => this.addProducer(new Producer(this, d)));
 }

 addProducer(arg) {
  this._producers.push(arg);
  this._totalProduction += arg.production;
 }

 get name() {return this._name};
 get producers() {return this._producers.slice()};
 get totalProduction() {return this._totalProduction;}
 set totalProduction(arg) {this._totalProduction = arg;}
 get demand() {return this._demand}
 set demad(arg) {this._demand = parseInt(arg);} // 숫자로 파싱해서 저장
 get price() {return this._price;}
 set price(arg) {this._price = parseInt(arg);} // 숫자로 파싱해서 저장

 // 생산 부족분을 계산
 get shortfall() {
  return this._demand - this.totalProduction;
 }

 // 수익을 계산하는 코드
 get profit() {
  return this.demandValue - this.demandCost;
 } 

 get demandValue() {
  return this.satisfiedDemand * this.price;
 }

 get satisfiedDemand() {
  return Math.min(this._demand, this.totalProduction);
 }

 get demandCost() {
  let remainingDemand = this.demand;
  let result = 0;
  this.producers
    .sort((a, b) => a.cost - b.cost)
    .forEach(p => {
      const contribution = Math.min(remainingDemand, p.production);
      remainingDemand -= contribution;
      result += contribution * p.cost;
    });
    return result;
 }
 ...
```

2. Producer 클래스
- 생산자를 표현
- 단순한 데이터 저장소로 주로 사용

``` js
constructor(aProvince, data) {
  this._province = aProvince;
  this._cost = data.cost;
  this._name = data.name;
  this._production = data.production || 0;
}

get name() {return this._name;}
get cost() {return this._cost;}
set cost(arg) {this._cost = parseInt(arg);}

get production() {return this._production;}
set production(amountStr) {
  const amount = parseINt(amountStr);
  const newProduction = Number.isNaN(amount) ? 0 : amount;
  this._province.totalProduction += newProduction - this._production;
  this._production = newProduction;
} // -> 리팩터링 대상
...
```

3. `sampleProvinceData()`
- 비즈니스 로직을 테스트하기 위해, JSON 형태의 가데이터 반환
``` js
 // 앞 생성자의 인수로 쓸 JSON 데이터를 생성
 // 이 함수가 반환한 값을 인수로 넘겨서 Province 객체를 생성

  function sampleProvinceData() {
    return {
      name: "Asia",
      producers: [
        {name: "Byzantium", cost: 10, production: 9},
        {name: "Attalia", cost: 12, production: 10},
        {name: "Sinope", cost: 10, production: 6}
      ],
      demand: 30,
      price: 20
    }
  }5
```

<br />
<br />
<br />

## 4.3 첫 번째 테스트
