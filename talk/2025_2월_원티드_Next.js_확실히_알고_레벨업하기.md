# 

### 강의 목표

- Next.JS는 어떤 특징을 가졌는가?
- 13+에서 변화된 점은 무엇인가?

<br />
<br />
<br />

# Week 1-1
그렇게 좋다는 'Next.JS', 왜 사용하시나요?

### 미리보기

1. 강의 오리엔테이션
2. Next.JS의 특징
3. 13+ 버전의 기능 짚어보기
4. 프로젝트 세팅해보기

<br />
<br />
<br />

## Next.JS의 특징

### Next.JS는 무엇인가?
> React 기반의 프레임워크이며 SSR과 SSG를 쉽게 구현할 수 있도록 설계된 도구 - chatGPT

**왜 많이 사용하는가?**
- Vercel에서 유지보수 -> 신뢰성
- SEO 지표는 실제 마케팅 등 개발 외 영역에서도 활용이 용이

### React와 Next 차이

|     | React                 | Next.JS              |
| --- | --------------------- | -------------------- |
| 1   | Library               | Framework            |
| 2   | Client Side Rendering | Sever Side Rendering |

- React에는 서버가 없음
- Next.JS라는 프레임워크가 Node.JS와 React를 함께 제공

<br />


**Library vs Framework**
<img width="585" alt="스크린샷 2025-02-18 오후 5 19 54" src="https://github.com/user-attachments/assets/1df13752-8241-4369-9098-a7b653a65250" />

- 라이브러리는 자율성이 매우 높으나, 프레임워크는 규칙과 원리 확고히 존재
- 프레임워크에는 신뢰성 있는 원리 존재 -> 협업 시 커뮤니케이션 시간 감소 효과 존재
- Similar) Eslint


<br />
<br />

### Rendering에 대해서
#### Client Side Rendering(CSR)
<img width="533" alt="스크린샷 2025-02-18 오후 5 22 09" src="https://github.com/user-attachments/assets/cb088a05-2b48-485e-a3b4-902f9966691a" />

1. 클라이언트가 페이지에 접속하기 위해 브라우저 주소창에 url을 작성 후 엔터를 치면, 서버\*에 GET 요청 전송
2. 서버\*에서 `index.html`을 클라이언트에 전송
3. 클라이언트에서 `index.html`을 기준으로 화면 구성에 필요한 `style.css`, `main.JS`를 요청
4. 3의 내용을 클라이언트에 전송
5. 서버(BE)에 API 요청 전달
6. 서버(BE)에서 DB 조회
7. DB에서 해당 내용 서버(BE)에 전달
8. 서버(BE)에서 로직 처리 후 API 응답을 클라이언트에 전달


> *) 서버라고 표현했으나, 로직을 수행할 수 있는 실질적 서버와 다르게 S3와 같은 정적 배포 저장소 또한 포함함


<br />
<br />

#### Sever Side Rendering(SSR)
<img width="560" alt="스크린샷 2025-02-18 오후 5 26 26" src="https://github.com/user-attachments/assets/41ce1457-3697-4bda-9244-34223c2c330a" />

1. 클라이언트가 페이지에 접속하기 위해 브라우저 주소창에 url을 작성 후 엔터를 치면, 서버(FE)에 GET 요청 전송
2. 클라이언트에서 서버(FE)에 API 요청 전달
3. 서버(BE)에 API 요청 전달
4. 서버(BE)에서 DB 조회
5. DB에서 해당 내용 서버(BE)에 전달
6. 서버에서 로직 처리 후 API 응답을 서버(FE)에 전달
7. 서버(FE)가 받은 데이터를 기반으로 완성된 HTML을 생성
8. 서버(FE)가 완성된 `index.html`을 클라이언트에 전송

<br />
<br />

**SSR은 속도가 빠르다**

- 초기 렌더링 속도 단축
  - CSR의 경우 단순 응답 시간(`index.html`을 받아오는 시점)이 빠름
  - 화면을 구성하는 시점은 SSR이 더 빠름
- 처리 성능과 네트워크 성능에 이점
  - 개인 기기보다 서버의 성능이 훨씬 뛰어남
  - SSR에서는 FE의 서버와 BE의 서버끼리 내부 통신을 하기 때문에 외부 통신에서 발생하는 라우터, 모뎀, ISP, LB, 방화벽 등 수많은 처리 과정이 간략화

<br />
<br />

**더 자세히 보는 SSR의 장단점**

| 1. 장점                 | 2. 단점                  |
| ----------------------- | ------------------------ |
| 1. [SEO](https://nextJS.org/learn/seo) 최적화           | 1. 서버 비용 증가        |
| 2. 저사양 기기 지원     | 2. 개발 복잡도 증가      |
| 3. API 은닉화           | 3. 응답 시간 증가        |
| 4. 브라우저 호환성 향상 | 4. 서버 의존도 증가      |
| 5. [FCP](https://developer.mozilla.org/ko/docs/Glossary/First_contentful_paint) 성능 향상        | 5. 페이지 전환 성능 감소 |

1-2. 서버에서 로직을 처리하고 완성된 html을 전달하는 것이므로 클라이언트 기기 의존성 줄일 수 있음

1-3. FE 서버의 주소(흔히 말하는 접속 당시 url)만 노출이 되고 BE 서버 주소는 노출하지 않음
  - SSR 단계에서 FE가 이미 API 요청을 했으면, API 요청 자체가 보이지 않을 것
  - 클라이언트에서 온 상황에서 Next.JS에서 제공하는 API 라우터를 사용하면 프론트엔드 서버로 보내지는 이점이 있음

1-4. 브라우저 별로 엔진이 다르기에, JS를 동작시키는 방식이 달라 호환성 이슈 존재. SSR은 JS를 서버에서 동작 시키므로 호환성 이슈를 줄일 수 있음

2-2. 다같이 사용하는 저장소인, 서버가 있다는 것은 FE가 신경 써야할 리소스가 증가, 개발 복잡도 매우 증가함

<br />
<br />
<br />

## 13+버전의 기능 짚기

### 왜 13+부터인가
> 12 -> 13에서의 혁신적인 변화와 달리, 13 -> 14 -> 15 간에서는 내부 코드 최적화 및 고도화를 진행함

**13에서 등장한 기능**
- App Router
- React Server Component
- Server Fetching

<br />

- 이미 메이저 버전도 많이 올라갔지만, 안정성을 고려해서 버전을 선택할 것
  - 프론트엔드는 버전이 빠르게 적용되어 안정성 검증이 어려움

<br />
<br />

### Page Router VS App Router
- 서버 사이드에서 데이터를 패칭하는 데에서 차이가 존재

||Page Router|3) App Router|
|--|--|--|
|SSG|1) `getStaticProps()`|RSC(React Server Component)|
|SSR|2) `getServerSideProps()`|Server Action|

<br />
<br />

**SSG와 SSR**

- CSR의 번들링은 JS 파일에 한정하지만, NextJS는 여기에 빌드할 때 API 요청을 실제로 실행하고, 원하는 시점의 html을 미리 생성하여 정적인 환경에서 준비된 html을 보여주는 것
- SSG와 SSR 모두 html을 생성하는 기능이지만, 생성 시점에 차이가 분명

1. SSG(Static Side Generation)
    - `next build(npm run build)` 시점에 실행
    - 내용이 모두 채워진 .html을 생성
    - 다시 빌드할 때까지 추가적으로 실행되지 않고 상태 유지
    - 정적 파일 생성

2. SSR(Static Side Rendering)
    - 요청 시점에 실행
    - 동적으로 .html을 생성하는 기능
    - 요청 시마다 재실행
    - 서버에서 API를 요청하고 실행

<br />
<br />

**1) getStaticProps**
<img width="614" alt="스크린샷 2025-02-18 오후 8 59 30" src="https://github.com/user-attachments/assets/cb35705b-3f6c-44e3-93fa-23482a1410ff" />

- 버셀의 레포를 `getStaticProps`를 이용하여 가져오고 반환, Page 함수에서 출력만 해주는 형태의 코드
- 프레임워크의 강제성인 부분
  - `getStaticProps`를 이용해야 함
  - 페이지 루트에 작성해야 함

<img width="578" alt="스크린샷 2025-02-18 오후 8 59 58" src="https://github.com/user-attachments/assets/427ab14b-adce-4a5d-95ef-3956ebb8a190" />

- 빌드 결과물을 살펴보면, SSG를 통해 `/article`이 생성되었음을 알 수 있음
- `/article` 앞에 색상이 칠해진 원이 존재함을 확인할 수 있고, 그 하단에는 '(SSG) prerendered as static HTML (uses getStaticProps)'라는 문구 존재

<img width="726" alt="스크린샷 2025-02-18 오후 9 00 22" src="https://github.com/user-attachments/assets/1f878f04-5757-4d3e-9643-76218568622d" />

- 파일 `article.html`이 실제로 생성된 것을 확인할 수 있음
- 빌드하는 과정에서 `getStaticProps`가 실행되어 데이터를 가져오고, 그 시점의 데이터를 기반으로 `article.html`을 미리 생성

<br />
<br />

**2) getServerSideProps**
- 페이지 단위로, `getServerSideProps`가 동작한 후에 하위 컴포넌트 렌더링 등이 동작
  - 즉, `getServerSideProps` 동작이 오래 걸릴 수록 같은 페이지 내 다른 컴포넌트들의 렌더링도 함께 늦어짐

<img width="698" alt="스크린샷 2025-02-18 오후 9 05 06" src="https://github.com/user-attachments/assets/62d54438-ba11-4954-9c23-57aa23d00f45" />

- 버셀의 레포를 `getServerSideProps`를 이용하여 가져오고 반환, Page 함수에서 출력만 해주는 형태의 코드
- 프레임워크의 강제성인 부분
  - `getServerSideProps`를 이용해야 함
  - 페이지 루트에 작성해야 함

<img width="724" alt="스크린샷 2025-02-18 오후 9 05 26" src="https://github.com/user-attachments/assets/d2021026-682e-4a0c-b070-a0810e54535b" />

- 빌드 결과물을 살펴보면, SSG를 통해 `/article`이 생성되었음을 알 수 있음
- '(Dynamic) server-rendered on demand`라는 문구가 존재
- 서버 환경에서 `article`에 접근할 때마다 `getServerSideProps`가 계속 실행

<img width="725" alt="스크린샷 2025-02-18 오후 9 05 46" src="https://github.com/user-attachments/assets/8f621be0-85bf-4a6d-b280-3874099aa4b6" />

- 결과적으로 `article.html`이 존재하지 않음

<br />
<br />

**getStaticProps와 getServerSideProps의 단점**
- 무조건 최상단에 위치해야 함
  - 필요한 컴포넌트 위치에 상관 없이 항상 최상단에 위치해야 하므로 props drilling 등을 선택해야함
  - 개발자 경험(DX) 저하
- 기존 JS, React에는 없는 독자적인 코드
  - 러닝커브 상승
- 내부 컴포넌트에서는 동작을 예측하기가 어려움
  - API 요청의 의도를 파악하기 어려움


<br />
<br />

**3) App Router**
1. RSC(React Server Component)
    - React 18버전에서 등장
    - Next.JS가 React를 기반으로 하기에 Next.JS에서도 사용할 수 있음
    - 서버에서 돌아가는 컴포넌트(간략화된 설명)
2. Server Action
    - Next.JS 13+버전에서 등장  
3. 장점
    - 보일러플레이트 없이 순수 Javascript와 같이 사용할 수 있음

<img width="688" alt="스크린샷 2025-02-18 오후 9 32 00" src="https://github.com/user-attachments/assets/c9717078-2ba8-45e8-903f-fea21fb7e386" />

- 위의 `getStaticProps`와 `getServerSideProps`의 코드를 App Router와 React Server Component 양식으로 변경
- async-await와 같은 비동기 코드 동작
- 보일러 플레이트 불필요

<br />
<br />
<br />

# Week 1-2
React Server Component 1

### 미리보기

1. React 18 동시성
2. RSC란?
3. RSC 이점

## React 18의 동시성
<img width="504" alt="스크린샷 2025-02-18 오후 10 53 28" src="https://github.com/user-attachments/assets/649deebd-7f04-4386-bbb9-178452793d43" />

- React는 동시성\*를 제공하기 위해 노력함
  - *) [동시성(Concurrency)](https://f-lab.kr/insight/understanding-concurrency-and-parallelism) : 여러 작업이 시간을 나누어 사용하여 마치 동시에 실행되는 것처럼 보이게 하는 기술
    - 병렬성은 실제로 여러 개가 동시에 진행, 동시성은 마치 동시에 진행되는 것처럼 보이게 하는 것
- NextJS는 React를 기반으로 한 프레임워크 -> React API를 이용해서 동작하므로 React에 대해 제대로 알아야 함
- React 18버전에서 React Server Component를 지원하고, 이후 Next 13 버전에서 React Server Component를 지원

<br />
<br />

### 왜 React는 동시성에 집중하게 되었나
**CSR 동작 방식**
<img width="503" alt="스크린샷 2025-02-18 오후 10 55 56" src="https://github.com/user-attachments/assets/71468afe-9627-41bf-aecb-19989cb7813a" />

- html을 가져오면 이는 비어있고, 여기서 css/JS를 호출하는 코드만 존재 -> 서버 요청 및 렌더링 시에도 html은 변경이 없어 빈 화면만 보여짐
  - 하이드레이션이 있다고 보기 모호함
- JS가 용량이 크거나, 네트워크 성능 또는 기기의 성능이 좋지 못할 시 빈 화면은 오래 보여짐

<br />
<br />

**SSR 동작 방식**
<img width="502" alt="스크린샷 2025-02-18 오후 10 57 07" src="https://github.com/user-attachments/assets/2d7d51c6-5528-489c-9d24-79f5652bbf48" />

- Nest 서버에서 먼저 API 호출, 데이터를 받아온 후에 하이드레이션\* -> 결론적으로 서버에서 html을 생성해서 클라이언트에 전달
  - *) [하이드레이션](https://www.reddit.com/r/Frontend/comments/125tuyw/what_is_hydration/?rdt=51953) : 브라우저가 화면에 렌더링한 요소에 상호 작용을 추가하는 과정
    - 클라이언트 DOM에 실제로 JS를 연결하는 과정
  - 2번에서는 실제 유저가 React 코드로 작성한 상호작용 불가
      - 하이드레이션 전에는 React 코드로서 작성한 부분 작동되지 않음
      - 2번의 파일은 JS 로드 전이므로 정적인 비대화형, 즉 보여지기만 하는 파일이므로 동작하지는 못함
- SSR에서는 상호작용 할 수 없는 html을 보다 빨리 보여주면서 UX 개선
  - *"사용은 못하더라도 미리 보여주자"*

<br />
<br />

### React 18 이전 버전의 문제점

1. 모든 Fetching이 완료되기 전까지는 어떤 것도 보여줄 수 없음
    - SSR에서 만일 용량이 큰 JS 파일 또는 호출이 오래 걸리는 API가 적용되어야 할 화면이 있다면, 데이터 fetching(1번 단계)이 오래 걸림
    - 따라서 html 생성 시점도 늦어지게 됨
2. 모든 JS가 로드되기 전까지는 Hydrate 할 수 없음
    - SSR에서 만일 용량이 큰 JS 파일이 있다면, 비대화형 html의 상태가 지속되는 시간이 길어진다.

<br />

> Streaming HTML과 Suspense를 도입하여 해결<br/>
> -> 각 컴포넌트 별로 SSR의 전체 과정을 동시에 진행

<br />
<br />

## RSC 개념(React Server Component)

<img width="505" alt="스크린샷 2025-02-18 오후 11 40 39" src="https://github.com/user-attachments/assets/e9f88031-157a-47ae-84fc-9765a5b4f1fa" />

- SSR 구현하는 방법 중 하나에 RSC가 포함되어있다고 볼 수 있다

> 서버에서 실행되는 React 컴포넌트

(Next.js 환경 한정)

1. SSR
    - Nextjs 서버에서 `getServerSideProps` 실행되며 데이터 fetching
    - 데이터 fetching 완료 후 컴포넌트 렌더링을 실행해 비대화형 html 생성 -> `컴포넌트 실행 시점_1`
    - 클라이언트에서 js 로드 후 hydrate 과정을 거쳐 완벽한 html 완성 -> `컴포넌트 실행 시점_2`
    - *서버와 클라이언트에서 컴포넌트 실행*
2. SSR + RSC
    - Nextjs 서버에서 RSC 실행되며 데이터 fetching 및 렌더링 진행 -> `컴포넌트 실행 시점_1`
    - 렌더링 완료 후 생성된 html을 클라이언트로 전달
    - 클라이언트는 별도의 hydrate 과정 없이 전달 받은 html 사용
    - *서버에서만 컴포넌트 실행됨*
    
    <br />
    
- RSC 컴포넌트 파일은 서버에서 사용되고 하이드레이트에 사용되지 않기 때문에, 번들 파일에 포함되지 않아 번들 파일의 크기가 감소함
  - JS 파일 받아오는 시간이 줄어들고 시간이 줄어듦
- 그러나 RSC 컴포넌트는 JS를 포함하지 않기 때문에 이벤트 핸들러 등 client 기능 사용 불가
  - JS 없이는 client의 DOM을 처리할 수 없기 때문에

### 직렬화
> RSC는 직렬화(serialization) 가능한 값만 전달할 수 있다

<img width="505" alt="스크린샷 2025-02-18 오후 11 54 46" src="https://github.com/user-attachments/assets/932e9210-a440-4680-8860-3029e40b0d4d" />

- 협의한 포맷으로 정해주는 과정
- React는 [React만의 직렬화 방식(React Payload)](https://30dayscoding.com/blog/what-is-payload-in-react)을 사용(JSON과 유사), 그러나 함수(function)은 직렬화 불가

<br />
<br />

## RSC 이점

<br />
<br />